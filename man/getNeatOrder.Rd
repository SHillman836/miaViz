% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getNeatOrder.R
\name{getNeatOrder}
\alias{getNeatOrder}
\alias{getNeatOrder,matrix-method}
\title{Sorting by radial theta angle}
\usage{
getNeatOrder(x, ...)

\S4method{getNeatOrder}{matrix}(
  x,
  subset = NULL,
  dimensions = c(1, 2),
  centering_method = c("mean", "median", "none"),
  decreasing = FALSE,
  ...
)
}
\arguments{
\item{x}{A matrix containing the ordinated data to be sorted. Columns should represent the principal components (PCs) and rows should represent the entities being analyzed (e.g., features or samples).}

\item{...}{Additional arguments passed to other methods.}

\item{subset}{A vector specifying a subset of rows to be used and retained. If NULL, all rows are used.}

\item{dimensions}{A vector of length 2 specifying the columns of the matrix to use for the X and Y coordinates.}

\item{centering_method}{A character string specifying the method to center the data. Options are "mean", "median", or "none" if your data is already centred.}

\item{decreasing}{A boolean that when true sorts the rows in a descending order by radial theta angle. Default is False.}
}
\value{
A vector of row names in the sorted order.
}
\description{
\code{getNeatOrder} sorts already ordinated data by the radial theta angle.
This method is useful for organizing data points based on their angular
position in a 2D space, typically after an ordination technique such as PCA or NMDS
has been applied.

The function takes in a matrix of ordinated data, optionally
centers the data using specified methods (mean, median, or none), and then calculates
the angle (theta) for each point relative to the centroid. The data points are then
sorted based on these theta values in either ascending or descending order.

One significant application of this sorting method is in plotting heatmaps.
By using radial theta sorting, the relationships between data points can be preserved
according to the ordination method's spatial configuration, rather than relying on
hierarchical clustering, which may distort these relationships. This approach
allows for a more faithful representation of the data's intrinsic structure as captured
by the ordination process.
}
\examples{
# Load required libraries
library(mia)

# Load the dataset
data(peerj13075)

# Agglomerate by Order and transform the data
tse_order <- agglomerateByRank(peerj13075, rank = "order", onRankOnly = TRUE)
tse_order <- transformAssay(tse_order, assay.type = "counts", method="relabundance", MARGIN = "samples", name="relabundance")
tse_order <- transformAssay(tse_order, assay.type="relabundance", method="z", MARGIN = "features", name="z")
z_transformed_data <- assay(tse_order, "z")

# Get the top taxa and perform PCA
top_taxa <- getTopFeatures(tse_order, top = 10, assay.type="z")
top_feature_data <- z_transformed_data[top_taxa, ]
pca_results <- prcomp(top_feature_data, scale = TRUE)
scores_pca <- pca_results$x[, 1:2]

# Sort by radial theta and subset the transformed data
sorted_order <- getNeatOrder(scores_pca, dimensions = c(1, 2), centering_method = "mean")
ordered_transformed_data <- z_transformed_data[sorted_order, ]
}
